# 标C笔记
## 一、注释
/*注释内容*/
//注释内容
printf("要输出的内容\n");

## 二、整型变量
%d是一个占位符，他只能够打印整数

int num = 123； 
int代表的是一个整形数据，num代表是这个变量的名称，= 123是代表给这个变量的值初始化成123。

整数类型
长整型和短整形
int是一个整数类型的数据

短整形short表示
-32768到32767

无符号短整形用unsigned short
0到65535

C语言程序中，是可以进行各种数据之间的运算！

num1 = num - 10；
代表的是，吧num - 10所得结果赋值给num1

长整型范围是-2的32次方到2的32次方
long int 

无符号长整型范围0到2的32次方减一
unsigned long int 

无符号整形unsigned int

printf标准输出函数
scanf标准输入函数

int num =10;
printf("%d",num);

printf标准函数是从变量中拿出数据
scanf标准函数就是从变量中放入数据

数字7上面的符号  &
&叫做地址符
scanf标准函数不能够使用'\n'换行

scanf不能输入与指定的数据类型不同类型的数据
否则，下次输入会出错！

scanf标准函数，从键盘得到一个数据，并没
马上传送到计算机里面，这个数据先经过输入
缓冲区，然后就不动了，scanf并没有直接的
从键盘上获取数据，而是从输入缓冲区里面
获取数据！

浮点型（实型）
单精度浮点型和双精度浮点型
单精度浮点型用float
双精度浮点型用double
输出浮点型数据的占位符，使用%f
使用占位符%g可以输出的时候省略后面的0

占位符%后面加上.n可以指定输出小数点后面n个小数

单精度浮点型变量，小数点后面有效位数只有7位
超过无效
双精度浮点型变量，小数点后面有效位数只有17
位，超出无效！

%nf,n代表一个数字，f是浮点型数据输出的占位符
%nf代表输出的时候空格n次，然后在输出


\n  代表换行字符
\r  代表回车字符
\t  制表符
\\  代表\
\'  代表'
\"  代表"

字符类型用char表示
用%c作为占位符进行输出字符类型的变量

字符类型的数据有两种身份
数字身份  字符身份

字符类型的范围255个不同的数字身份 0-244

ASCII码表

A  --  65
a  --  97
97 - 65 = 32

short 
unsigned short
int
long int
unsigned long int
float
double
char  

sizeof

short占用内存2个字节
unsigned short占用内存2个字节
int占用内存4个字节
long int占用内存8个字节
unsigned long int 占用内存8个字节
float占用内存4个字节
double占用内存8个字节
char占用内存1个字节

常量必须对他初始化，而且常量的值不
能够改变
在普通变量类型名称前面加上const即可
定义为常量
const int b = 10;
常量是只读变量，他的值无法被改变

自增自减运算
a = a++；自增一
a = ++a；

a++，a在前面，++在后面，他会先吧a的值
赋值，然后在进行自增计算！
++a，++在前面，a在后面，他会先对a进行
自增计算，然后在进行赋值！

自减运算
--a 先计算后赋值
a-- 先赋值后计算

% 取余

各种数据类型所对应的占位符
char      --    %c和%hhd
%c用来打印字符身份，%hhd用来打印数字身份

unsigned char  --  %c和%hhu
short          --  %hd
unsigned short --  %hu
long ing       --  %ld
unsigned long int -- %lu
int            --  %d
unsigned int   --  %u
float          --  %f和%g
double         --  %lf和lg

%nd可以打印整数，n是一个数字，代表
一共占用多少位
%-nd可以让打印结果对齐
%0nd可以用0填充空位
%n.mf可以打印单精度浮点型
打印结果一共占用n个位置
其中小数点后面占m个位置

计算机内存划分成大量的字节
，任何两个字节的大小是一样的
2的整数次方，最多不能超过8个
sizeof就是用来计算变量占用内
存多少个字节

16
一十六
壹拾陆

十进制

二进制
0110 1110

2+4+8+32+64=110

int num = 110；

0110 1110
0000 0000
0000 0000
0000 0000

59  。。。。1
29  。。。。1
14  。。。。0
7   。。。。1
3   。。。。1
1   。。。。1
0   。。。。0
0           0

0011 1011
原码 

所有非负数的原码和补码都是一样的
八进制和十六进制 

0011 1011
00 111 011
0  7   3

0011 1011的八进制：073

在C语言中所有以八进制方式编写的数字
以0开头

%o是一个和八进制表示形式相对应
的占位符

十六进制

0000 0101     5

-5+5= 0

**** ****  +  0000 0101  =  0
↑不可行的，因为没用任何数和他加起来得0

0000 0101和**** ****
1 0000 0000

1 0000 0000 - 0000 0101
=1 0000 0000 -1 - 0000 0101 + 1
=1111 1111 - 0000 0101 +1
=1111 1010 + 1
=1111 1011
1111 1011 
0000 0101
负数二进制的表示方式的计算规则是
正数二进制按位求反在加1

1011 0011
0100 1100 + 1
0100 1101
使用这个方法计算得到的就是负数的补码
，所以他可以直接记录在字节当做
补码

1011 1111


整形
0000 0000
0000 0000
0000 0000
1011 1111
0100 0001 = -65

时间转换：
1000秒
小时：分钟：秒数
10:30:12

十进制转换二进制
128  64  32  16  8  4  2  1

，操作符
逗号操作符

+  -  *  /  %  ，
，操作符吧两个表达式合并成一个
合并后的表达式计算结果是后一个
表达式的计算结果

* / %     + -    =    ，

num = 4 + 7,8 - 6；

需要两个数字配合使用的操作符叫做双目操作符

只需要一个数字配合使用的操作符叫做单目操作符

num +=10    num = num + 10


有一种表达式，无论你写的多复杂，他的结果只
两种，真和假，就是0和1
布尔值，真用1（true）表示，假用0表示
（false）

逻辑表达式  
双目逻辑操作符
==  ！=   <=    >=  <   >
!是一个单目逻辑操作符，表示求反
逻辑操作符优先级比算数操作符要低

if
流程控制

输入两个数字，然后输出最大值
如果
if (num < num1） 
{
        printf("最大值是%d\n",num1);
}
else
{
        printf("最大值是%d\n",num);
}

复杂逻辑表达式
逻辑操作符与（&&）和逻辑操作符或（||）

如果两个逻辑表达式的计算结果都为真
则使用&&合并后逻辑表达式结果也是真

如果两个逻辑表达式其中有一个是真的
使用||合并后的逻辑表达式也是真的

短路特性
0
1
逻辑或短路特性，只要其中一个表达式结果为真
后面的表达式则不再计算，直接忽略掉了，
整条表达式结果为真

  
位运算操作符

位操作符对字节中二进制位进行操作

按位与（&）吧对应数位上的数字进行操作

0 & 0       0
1 & 1       1
0 & 1       0

3     0000 0011
5     0000 0101
      0000 0001
	          1

按位与可以吧字节中的某些二进制位清零
任何一个二进制位和1做按位与结果保持不变
任何一个二进制位和0做按位与，结果一定是0

按位或（|）
吧对应位数上的数字进行或计算
0|0   0
1|1   1
1|0   1

3   0000 0011
5   0000 0101
    0000 0111
	        7

按位或可以吧一个字节中某些数位设置成1
任何数位和0做按位或保持不变
任何数位和1做按位或结果一定是1

按位异或（^）可以吧对应位数上的数字进行
异或计算

0^0   0
1^1   0
1^0   1

3   0000 0011
5   0000 0101
    0000 0110
	        6

按位异或可以吧字节中某些二进制位求反
任何二进制位和0做按位异或运算结果保持不变
任何二进制位和1做按位异或计算，结果一定变化

~（按位求反）是单目操作符，他可以吧一个字节中
的二进制位求反

0x83

1000 0011
0111 1100
=0x7c

移位操作符可以吧一个字节中所有二进制位
统一向左或者向右指定的位数移动

左移操作符使用<<表示
右移操作符使用>>表示

左边的数字是要进行移位操作的数字，右边的数字
是要移动的位数

0111 0011
0001 1100

左移操作中右边空出来的位置一定填充0
右移操作中有符号数字一定填充符号位
无符号数字一定填充0
int num = 3；
3  0000 0011
3 << 2
0000 0011
0000 1100

如果移位过程中没有丢失有效数据，则
右移n位相当于除以2的n次方，左移n位
相当于乘以2的n次方

三目表达式
if类似



num = num < num1 ? num1:num;


强制类型转换

如果一个表达式中包含多个不同类型的数据
必须首先把他们转换成同一类型然后才能
计算，这个转换过程是计算机自动完成的
叫做隐式转换

10 + 10 = 20
int num = 0；
（强制转换成的数据类型）变量名称
（char）num
（short）num
（float）num
 printf("num是%lf\n",(double)num);

(double)num

强制类型转换的实现方式是：
临时生成一个新的数据，使用旧的数据对新的数据进行
赋值，以后的操作都采用的是新的数据

switch分支
由用户输入一个数字，这个数字只能是0-3之间是0-3之间
这四个数字分别代表一个季节
0代表春季
1代表夏季
2代表秋季
3代表冬季

switch（不能写一个逻辑表达式）
用case来作为判断语句
格式：
case 判断条件：
			满足条件执行的程序

break停止执行当前大括号内的程序
if类似{
}
else{
}


分支嵌套

循环语句
for(循环变量；逻辑表达式；循环变量的变化规律)
{
	循环体
}
for(1;2;3)
{
	4
}
1、声明循环变量
2、确定循环变量变化过程中开始数字和结束数字
3、编写小括号描述循环变量的变化过程
4、编写大括号里面的语句用来处理循环变量所代表的数字

[1,2][4,3,2][4,3,2][4,3,2]......



1+2+3+4+5+......+97+98+99+100=？

1个100
50 X 100 = 5000 + 50
         =5050

在循环中使用break语句后循环中的一切都会停止
循环变量也不会再改变，所以采用这种方式计算
的循环逻辑表达式计算结果为真！

continue语句可以吧当次大括号中后面的语句全部
跳过

while循环

while（逻辑表达式）
{
	反复执行的语句
}

利用循环输出0-10

不会结束的循环叫做死循环
while循环也可以使用break和continue结束

while（1）
{
	2
}
[1][2,1][2,1][2,1]......
while循环他的逻辑表达式扩号内，不具备
循环变量的变化规律描述的语句
因此需要手动给他的循环变量编写变化规律
比如num++！

do...while循环


do
{
循环体
}while（逻辑表达式）；
使用do...while循环的特点：
可以保证大括号内的语句至少执行一次


do
{
	2
}while（1）；
[2,1][2,1][2,1][2,1]......
while循环和do...while循环一定别忘记
编写循环变量的变化规律
如num++；

输入缓冲区

scanf（%d %d）；

scanf("%*[^\n]");
scanf("%*c");
↑用来清空输入缓冲区
0 1
清空输入缓冲区代码：
for (num = 0;num <= 5;num++)
        {
                do
                 {
                         if(a != 0)
                        {
                                scanf("%*[^\n]");
                               scanf("%*c");
                        }
                        a = 1;
                }while(!(scanf("%d",&num1)));
                 printf("你输入了%d\n",num1);
         }

数组
使用数组表示多个连续的同类型的存储位置
最靠前的编号0，最后一个存储位置的编号是
个数减一！
num  
使用数组的时候，不可以超过下标
num[10]
num[0] = 0
num[1] = 1
num[2] = 2
num[3] = 3
num[4]
num[5]
num[6]
num[7]
num[8]
num[9]
利用循环吧数组中每一个存储位置遍历一次
进行初始化

如果对数组初始化的时候，有些位置没有被初始化
那么这些漏掉的位置就会被初始化为0

只有一个下标的数组称为一维数组

随机数
我们计算机所做的随机数都是伪随机

rand标准函数用来获得随机数
使用rand标准函数需要使用stdlib.h头文件

srand标准函数可以用来设置随机数种子
srand（）
随机种子，吧时间当做随机种子种下即可

time可以用来获取当前时间，得到的时间是一个
整数类型

代表的是1970年1月1日0时0分0秒到我们
现在此时此刻的时间

除以一个数得到的余数一定不会大于被除数
100 / 11 = 9 .......1
214124234333534645654  / 100 
1-36之间的数（允许出现重复数字）

一维数组：只使用一个下标就可以表示某个存储位置
的数组叫做一维数组
二维数组：使用两个下标就可以表示某个存储位置
的数组叫做二维数组
二维数组声明的时候需要提供两个数字
第一个数字表示分了多少组
第二个数字表示每组多少个存储位置

使用循环嵌套对二维数组进行初始化！

麦穗  10  一维数组

main（）是主函数

void是无类型

实际参数 形式参数
实参   形参
函数外面不可以使用函数里面的数据
函数里面也不可以使用函数外面的数据

函数调用结束是可以遗留一个数字
这个数字是瞬间存在的，转瞬即逝

函数声明的方式

exit标准函数可以立刻结束一个函数的运行
要使用exit标准函数需要包含头文件stdlib.h

exit = return
exit（1） = return 1；
exit（0） = return 0；

数组形参


用数组做形参可以传递存位置而不仅仅是传输数据
函数对数组参数所做的修改会影响到函数的调用
数组做形参可以实现双向数据传递
这种参数叫做输入输出参数

普通变量做形参只能把数据从调用函数传递到
被调用函数，这种参数叫做输入参数

数组名称和存储位置的地址都可以作为实参和数组形参配对
数组形参无法表示其中包含的存储位置个数，因此
需要另一个形参表示这个信息

最多返回一个数，

文件操作的相关标准函数


1、fopen标准函数用来打开一个文件
2、fclose标准函数关闭文件
3、fread/fwrite用来想文件读写数据

文件中记录的都是字符，可以给人看的，
二进制文件是存储数据的，内存中的二进制内容

文件打开模式
r   只能读文件，读操作
    从文件头开始，文件必须事先存在
r+  在前一个模式的基础上增加修改能力

w   只能修改文件内容，修改操作从文件头开始
    如果文件事先不存在则创建新文件，如果文
	事先已经存在则删除原有文件中的内容
w+  在前一个模式的基础上增加读能力

a   只能修改文件内容，如果文件事先不存 
    则创建新文件，如果文件事先已经存在
	则在源文件的原有内容的基础上追加新内容
	
b   可以和前面任何一种模式混合使用，这模式
    表示以二进制方式对文件进行操作

fopen标准函数打开文件是有可能失败的


 FILE *p_file = fopen("a.txt","w");
         if (!p_file)
         {
                 printf("文件打开失败\n");
                 return 0;
         }
         fclose(p_file);
         p_file = NULL;

		 ↑标准文件操作框架
		 


fread/fwrite用来想文件读写数据
四个参数
1、数组（fread会吧文件中得到的内容存放到
数组的存储单位内，fwrite会吧数组中存储位置
的内容写入文件）
2、数组中单个存储位置的大小
3、希望使用存储位置的个数
4、要操作的文件



利用文件的读和写  文件的拷贝


函数递归
自己调用自己的函数叫做递归函数


生命周期和作用域

这两个属性决定什么时候在什么地方可以
使用什么变量

作用域是指使用变量名称的所有语句的总和

全局变量
	声明在所有函数之外的变量
	全局变量整个程序都是可以使用的
局部变量
	声明在函数内部的变量叫做局部变量
块变量
	块变量是声明在语句内部的


生命周期是指变量的存储位置可以被使用的时间
范围

全局变量的存储位置在程序开始的时候被分配
程序结束的时候被回收
全局变量的生命周期包含整个程序的运行期间

局部变量的生命周期只到这个函数执行结束
形式参数的生命周期和局部变量的生命周期一样

块变量的存储位置在语句开始的时候被分配
在语句结束的时候被回收，他的生命周期包含
整个块语句运行期间

变量的类型

三种类型的变量可以重名

就近原则

一条语句中使用的变量一定是作用域包含这条语句的所有
同名变量中声明语句距离他近的那个变量
这就叫做就近原则

1、auto用来声明自动变量，所有局部变量
都缺省的是自动变量，几乎不需要使用这个关键字

2、static关键字用来声明静态变量


10 10  

3、const  常量


4、volatile关键字用来声明多变变量，这种
变量的内容随时可能被改变，而且这种改变
的原因不是我们的语句造成的！

volatile关键字告诉编译器i是随时可以发生改变的
每次使用他的时候必须从i的地址中读取，因为编译器
生成的可执行代码会从i的地址读取数据放在k

而优化的方法就是，由于编译器发现两次从i
读取数据的代码之间的代码没有对i进行过操作
他会自动吧上次读的数据放在k中，而不是从新
从i里面读取，这样一来，如果i是一个寄存器
变量或者端口数据就容易出错，volatile关键字
有个优点：可以保证对特殊地质的稳定性访问

指针变量是一种特殊的变量
指针变量也对应着一个存储位置，跟普通变量
不同的是指针变量的存储位置里面记录的是
另一个存储位置的地址

指针变量只有和一个普通变量存储位置关联后
才能够使用
	   
如果，既没有给指针有效地址，也没有给指针空
地质，那么这是一个野指针，一定要避免野指针
的出现
一定必须肯定绝对不能让野指针出现
指针变量一定要初始化

指针变量前加*（星号，数字8上面的那个符号)
可以代表对应普通存储位置的地址
如果不加星号那么对应的就是他自己的存储位置
的地址


从键盘得到三个数字，使用指针变量找出其中最
大的数字（普通变量的内容可以被改变，但是不
可以丢失数据）

把数字从大到小打印（普通变量的内容不可以
改变，但不能都丢失数据）使用指针完成！

指针变量强制类型转换

%p占位符用来打印地址数据

指针变量的类型转换过程中不会导致地址数据受
影响

 printf("(char*)p_num是%p,*(char*)p_num是%d\n",
 (char*)p_num,*(char*)p_num);
 
 指针变量在类型转换过程中影响的是和指针
 配对的普通变量存储位置

void*类型的指针
这种类型的指针只表示了其中记录了一个地址数据
但是没告诉我们可以根据他找到什么类型的
存储位置
void型指针通常用来接收来源不明的数据地址

void型指针用来做形参

指针数据可以实现双向数据传递，因此他们都是
输入输出参数


指针形参可以实现双向数据传递，因此他们都是
输入输出参数

num是10,num1是3
num是3,num1是10


△day52.c    重点



函数指针

指针类型变量课作为函数的返回值使用
指针类型的返回值可以用来表示一个存储位置

不可以吧局部变量的地址复制给指针类型的返回
变量（局部变量的生命周期仅在这个函数调用期
间）

地址数据所能参与的四则运算

只能够+和-，不能乘和除！
加和减也有限制

地址 + 整数
地址 - 整数
地址 - 地址

以上计算中的整数都是有单位的，单位由地址数据
的类型决定

地址数据相减的结果是整数，这个整数也是有单位
的，单位由地址数据的类型决定

程序在内存中是分段存储的

代码段
		存放语句转换成的数字，程序运行的时
		候不可以被修改

全局段
		用来记录全局变量和静态变量的存储位
		置，这个段落的大小，不会随着程序的
		运行而发生改变
		
栈
		用来存放局部变量，块变量，形式参数
		和返回值，这个段落的大小是随着程序
		的运行而不断在改变的，每当一个函数
		调用出现的时候，就从这个段落一段落
		分配一段空间来记录他自己的变量，当
		函数调用语句结束的时候，他被分配的
		空间都会被计算机收回
		
		不同的函数调用的空间遵循后进先出的
		原则

堆 
		这个段落用来存放动态分配的存储位置
		动态变量的分配和回收工作由程序员编
		些的语句管理，如果管理语句错误会产
		升严重的后果
		
		
字符串是专门用来记录大量文字信息
		
字符串中包含连续多个字符类型的存储位置
使用这些连续的存储位置来记录文字信息

ASCII码表为0的字符表示字符串的结束位置
\0  

在程序中使用第一个存储位置的地址表示所有
文字嘻嘻

所有的字符串都可以使用char*类型指针表示
只要把第一个字符存储违的地址记录在指针中


字符类型变量用单引号赋值
字符窜必须使用双引号！

%s占位符用来打印多个连续的字符（字符窜）


字符窜类型存储位置不允许被修改


字符窜字面值

字符串字面值会在编译好以后用首字符地址代替
并且在末尾加上\0

“abc” “def”“abcdef”

字符数组也可以当做字符窜使用

char ch[] = "abc"; 

字符窜不可以用操作符进行操作


字符串标准函数

string.h

strlen标准函数用来计算字符串中有效的字符个数
\0

“ABCDEF”

strcat标准函数用来吧一个字符窜追加到另一个
字符串的末尾
会修改一个原来的字符串，用返回值表示新的字
符串
这个函数可能造成数组下标越界，
所以是不安全的
strncat可以指定最多合并多少个字符串到第一个
字符串，所以可以避免下标越界

strcpy标准函数可以复制一个字符串
调用函数需要提供存储位置，用来记录复制得到的
新字符串
也可能造成下标越界，也是不安全的
strncpy标准函数，功能和strcpy一样，但是只复制
前n个字符，所以这个是安全的

strcmp标准函数比较两个字符串的大小

返回1表示前一个字符串大
返回0表示一样大
返回-1表示前一个字符串小


strncmp标准函数只比较两个字符中前n个字符


字符窜输入
使用scanf标准函数从键盘获取字符窜是不
安全的

fgets函数可以从任何文件中得到一个字符串
并且放在一个数组中

键盘是标准输入设备，用标准输入文件表示
（stdin）
显示器是标准输出设备，用标准输出文件表示
（stdout）

需要三个参数


1、数组名称（得到的字符串存储在这个数组
的存储位置当中）
2、数组中存储位置的个数
3、要读取的文件（stdin）
函数会在数组最后加\0结束字符

如果你输入的不够多，他就会吧回车也给读取
因此会出现空格


采用二维数组可以记录多个相关字符串
以后可以采用循环依次处理其中每个字符串

有可能造成存储位置的浪费

什么类型的变量可以用来存储一个指针类型的
地址
二级指针

主函数也有参数

文件位置指针
文件位置还真用来记录下一次文件操作的开始
位置
这个指针会记录一个整数，这个整数代表这个
位置到文件头的距离
ftell标准函数可以得到位置指针的数值

rewind标准函数可以设置位置指针到文件开头
fseek标准函数可以吧文件位置指针移动到文件
中的任何位置

三个参数
1、要操作的文件
2、要移动的位置
3、↓下面这三个参数之一

SEEK_SET   0文件头作为基准位置
SEEK_CUR   1当前位置作为基准位置 
SEEK_END   2文件尾作为基准位置 


预处理指令
#define用来定义宏

根据用户给定的半径计算圆的周长

2 * 3.14f * 半径

gcc —E可以查看预处理后的结果

编译的时候编译器会吧宏所代表的值
替换掉宏的名称
不要在宏定义语句中使用赋值操作符

彩票程序

宏也可以用来给一个计算公式起名字
宏可以用来给一个计算公式起名字
宏可以使用参数表示计算公式中的未知的内容
参数的个数没有限制


不要使用自增或者自减的计算结果作为宏的参数
只用

宏操作符
#和##
#操作符：可以吧宏的一个参数转换成字符串字
面值

##操作符：可以吧一个代表标识符的参数和其他
内容合并成一个新的标识符

int main()
  {
   printf("STR(abc)是%s\n","abc");
   int l_num = 0;
   printf("%d\n",l_num);
   return 0;
  }

条件编译可以在编译的时候编译某些语句而忽略
其他语句

1、
#ifdef <宏名称>
...
#else
...
#endif

2、
#ifndef <宏名称>
...
#else
...
#endif



#endif表示结束位置，因为没用用大括号抱起来

使用gcc编译源文件的时候，加上选项-D，可以
定义一个宏

-D选项使用方法，如：-DONE
其中ONE是宏名称，-D是选项，中间无空格


ifdef和ifndef区别：ifdef是条件满足则执行
ifndef是条件不满足则执行

多文件编程

多文件编程编写的时候，某个函数必须属于
某个文件，一个文件中可以包含多个函数

多文件编程的编写步骤
1、吧所有函数分散在多个不同的.c源文件
中（通常主函数单独写在一个源文件中）
2、为每个.c源文件编写对应的.h头文件
（如果源文件中只包含主函数则不需要编
写对应头文件）
3、为每个.c源文件找到所有需要的头文件并
包含进来
4、使用gcc命令完成编译，要把所有源文件名称
都写在命令中

<>包含头文件是从编译器的目录中搜索头文件
"  "包含头文件，是从源文件所在目录搜索头文件

#ifndef __ADD_H__
#define __ADD_H__
int add(int,int);
#endif
↑这样就可以避免重复编译头文件！

extern关键字可以用来欺骗gcc编译器


静态全局变量不可以被其他源文件使用

结构体可以用来统一存储过多个不同的数据类型

结构体仅仅只是一种数据类型，他本身不
占有内存

struct

结构体本身是一个数据类型，他的作用是用来
声明结构体变量

可以使用struct关键字和结构体名称一起作为
数据类型名称来声明结构体变量

typedef关键字可以给结构体变量取别名（当外号）

可以在声明结构体的时候立刻取别名，这个时候可以省略
结构体本身的名称

声明一个结构体表示手机，一个手机包含以下信息
品牌
型号
价格

如何使用结构体！


iphone num；

使用如下格式表示结构体中的子变量

结构体变量名称.子变量


结构体变量是可以初始化的
初始化方法和数组一模一样


结构体形参和返回值

计算两个点的中点

从键盘得到两个点的位置信息，并记录在两个
结构体变量中
记录这两个点的位置并计算距离然后记录在新的
结构体变量中

使用普通变量作为返回值只能返回一个数字
使用结构体变量作为返回值可以返回多个数字

结构体变量可以作为函数的形参和返回值
但是最好不要用，因为会浪费时间浪费空间

应该使用结构体指针

通过结构体指针表示结构体内部子变量的时候
需要使用操作符->
例如：p_start->x


生命周期


枚举类型

enum用来声明一个枚举类型变量
枚举类型不用初始化 
声明格式：enum{变量名称}；

枚举类型和宏功能从某种意义上讲功能是一样的
什么时候用枚举什么时候用宏？

如果并不关心转换成的数字是几，那么就可以用
枚举类型先把这些数字放进程序里，如果非要结
准确，那就得宏

转换成的数字从0开始依次递增

枚举变量并没什么实际作用

枚举变量只是让你的程序看起来更容易看懂
更方便而已！

联合类型也是一种数据类型，和结构体一样
联合类型也包含很多子变量
使用方法一模一样
union

结构体的变量互不干扰，而联合体的子变量却
共享同一个位置
所有子变量都只有一个存储位置

联合中的子变量可以看成是同样内存空间
的不同使用方式


动态分配内存一定来自于堆这个段落


C语言有提供几个标注函数用来分配和回收
堆中的存储位置
使用动态分配内存函数需要头文件stdlib.h

malloc标准函数用来分配动态内存中多个连续的
存储位置
malloc标准函数会吧第一个字节的地址赋值
给返回值变量
void*
malloc函数和文件操作一样是有可能会失败的
因为文件操作就是一个动态分配内存

在失败的时候要给malloc函数NULL赋值给返回值

free标准函数用来回收不再使用的动态分配内存
所有动态内存在使用完毕后必须立刻释放
一次分配所得的内存必须统一释放


动态分配内存存储三个数字，分别是123
然后打印出来

4 * 3 12








